############################################################################################################
#
#    Locale name: Russian (Russia)
#
#    Authors (translators):
#
#        - German Vekhorev (DarksideCode)
#          https://github.com/MeGysssTaa/
#
############################################################################################################
logsCleaner.deleteSuccess=Автоматически удалён старый файл журнала {0}
logsCleaner.dateErr=Не удалось получить дату/время последнего изменения файла лога {0}
startup.classLoaderStats=Загружно классов: {0} (ошибок: {1}).
startup.jarErr.cantRead=Указанный JAR-файл не может быть открыт (нет прав?).
startup.jarErr.isDir=Указанный JAR-файл является катологом.
startup.jarErr.notExists=Указанного JAR-файла не существует.
startup.launchingProxy=Выполняется запуск прокси Keiko, пожалуйста, подождите...
startup.noArgsErr.line1=Пожалуйста, укажите JAR-файл, который Keiko будет проксировать, или название инструмента Keiko.
startup.noArgsErr.line2=Более подробную информацию Вы можете найти в инструкции по адресу:
startup.noArgsErr.line3=https://github.com/MeGysssTaa/keiko-plugin-inspector/wiki/Installation-Instructions
startup.proxyBegin=Начало проксирования {0}
logsCleaner.deleteErr=Не удалось удалить старый файл журнала {0}
pluginsIndex.beginning=Выполняется получение списка плагинов, пожалуйста, подождите...
pluginsIndex.invalidPluginYml=Недопустимый plugin.yml в плагине {0}
pluginsIndex.indexedInfo=Зарегистрирован плагин {0} (в файле {1}). Классы: {2}
pluginsIndex.indexErr=Файл {0} был пропущен. Это точно рабочий плагин?
pluginsIndex.numPluginsIndexed=Обнаружено плагинов: {0}
startup.workDir=Рабочий каталог Keiko: {0}
staticInspections.err=Произошла \
'{0} = 1 : критическая | * : некритическая' \
ошибка во время анализа плагина {1} (в файле {2})
staticInspections.desc.Static.ForceOp=|        Плагин {0} (в файле {1}) может выдавать отдельным игрокам на сервере статус оператора, \
таким образом наделяя их всеми правами и позволяя им делать всё, что захочется, без каких-либо \
ограничений. Если этот плагин - не плагин системы прав (пермишнов), тогда, скорее всего, \
это - троян, который позволяет взломать Ваш сервер без каких-либо усилий.
staticInspections.clean=|    Всё чисто.
staticInspections.suspicious=|    Обнаружен подозрительный код.
staticInspections.malicious=|    Обнаружен вредоносный код.
staticInspections.analysisName=|    Категория сканера: {0}
staticInspections.details=|        Подробности:
pluginsIndex.abortingLine2=Более подробное объяснение можно найти выше.
pluginsIndex.abortingLine1=Запуск прерван: обнаружена критическая ошибка во время получения списка плагинов
staticInspections.abortingLine1=Запуск прерван: обнаружен по крайней мере один вредоносный плагин либо плагин, который не удалось просканировать.
staticInspections.abortingLine2=Более подробное объяснение можно найти выше.
startup.proxyErr=Не удалось запустить прокси Keiko.
staticInspections.beginAll=Выполняется сканирование плагинов, пожалуйста, подождите...
staticInspections.desc.Static.SystemExit=|        Плагин {0} (в файле {1}) использует небезопасный код для завершения работы программы, который может \
привести к неожиданным проблемам. Например, в случае завершения таким образом работы сервер может не \
сохранить текущее состояние мира - он просто крашнется. Вообще говоря, плагины не должны заставлять \
сервер остановиться. Но если уж очень нужно, то для этого им следует пользоваться методами, встроенными \
в библиотеку (API) Bukkit/Bungee.
staticInspections.desc.Static.SystemProcess=|        Плагин {0} (в файле {1}) может использовать системные команды. То есть этот плагин может делать \
буквально всё что угодно с Вашим сервером (с Вашим устройством) в обход всех ограничений Keiko. \
Чаще всего, у плагинов нет нужды в использовании системных команд, поскольку есть более безопасное \
API Java практически для всех задач. Это значит, что есть высокая вероятность того, что цель этого \
плагина - навредить Вашему серверу.
staticInspections.desc.Static.NativesLoader=|        Плагин {0} (в файле {1}) подключает сомнительный машинный код. Это значит, что плагин не целиком \
написан на Java, и потому не может быть полностью проконтролирован Keiko. Другими словами, \
плагин может выполнять потенциально вредоносный код, который не будет просканирован Keiko.
staticInspections.desc.Static.DirectLeaks=|        Плагин {0} (в файле {1}) - пиратская копия платного плагина. Во-первых, это значит, что, \
скорее всего, этот плагин заражён. Во-вторых, это значит, что установленная сейчас версия \
этого плагина устарела, то есть может содержать уязвимости и ошибки. Запуская пиратские \
копии плагинов, Вы подвергаете свой сервер опасности, в то время как покупая подлинное ПО, \
Вы помогаете его разработке и получаете квалифицированную поддержку и обновления.
staticInspections.desc.Static.CodeInjection=|        Плагин {0} (в файле {1}), похоже, манипулирует своим собственным кодом, либо кодом \
других плагинов на Вашем сервере, во время работы. Потенциально это даёт ему возможность \
внедрить вредоносные инструкции в какой-то другой плагин, которому Вы доверяете, или и \
вовсе заразить весь Ваш сервер. Запуск этого плагина чрезвычайно опасен.
staticInspections.desc.Static.PermissionsPluginsAbuse=|        Плагин {0} (в файле {1}) явно взаимодействует с плагином на права (пермишны). Он может изменять права \
(пермишны) и группы любого игрока на сервере. Большинству плагинов не требуется даже знать, \
какой конкретно плагин на права (пермишны) Вы используете, потому что у Bukkit/Bungee есть \
общий интерфейс для проверки наличия прав и групп. Так что этот плагин потенциально опасен.
staticInspections.caches.err=Что-то пошло не так с системой кэшей статических анализаторов Keiko.
staticInspections.caches.resultCached=Результат проверки {0} кэширован для плагина {1} (в файле {2}) (результатов: {3})
staticInspections.caches.resultNotCached=Отсутствует кэш результата проверки {0} для плагина {1} (в файле {2})
staticInspections.caches.analysisStats=Завершён статический анализ плагина {1} (в файле {2}) ({3}/{0} кэшировано)
staticInspections.timeElapsed=Фаза статического анализа завершена за {0} секунд.
staticInspections.vulnerable=|    Обнаружен небезопасный/уязвимый код.
staticInspections.finishSummary=Всего предупреждений: {0} (критических: {1})
staticInspections.pluginSummary=|--- Предупреждений касательно плагина {2} (в файле {3}): {0} (критических: {1})
staticInspections.pluginResults=|--- Результаты статического анализа плагина {0} (в файле {1}):
logLevel.warning=предупреждение
logLevel.info=информация
logLevel.debug=отладка
logLevel.error=ошибка
identityFilter.err.skippingInvalidExclusion=Недопустимое исключение проигнорировано
identityFilter.err.invalidSyntax=Синтаксическая ошибка
identityFilter.err.invalidFilterType=Неподдерживаемый тип фильтра
staticInspections.proceedAnywayPrompt=Выявлены предупреждения! Продолжить в любом случае?
prompts.yes=да
prompts.no=нет
integrityChecker.abortingLine1=Запуск прерван: целостность некоторых плагинов была нарушена.
integrityChecker.abortingLine2=Более подробное объяснение можно найти выше.
integrityChecker.updated=Сохранена новая контрольная сумма плагина {0}: {1} 
integrityChecker.updatePrompt=|--- Проигнорировать это предупреждение и запомнить новую контрольную сумму этого плагина?
integrityChecker.violationPlugin=|--- Код плагина {0} изменился с момента последнего запуска. Обновляли ли Вы его?
integrityChecker.violationCached=|    Сохранённая контрольная сумма: {0}
integrityChecker.violationActual=|    Обнаруженная контрольная сумма: {0}
runtimeProtect.dac.enabled=Доменный контроль доступа Keiko (DAC) успешно активирован.
runtimeProtect.dac.invalidDefCfg=Недопустимая конфигурация по умолчанию DAC для операции {0}: "{1}". \
Будет использовано правило ALLOW. 
runtimeProtect.dac.ignoringContraRule=Проигнорировано противоречащее правило DAC для операции {0}: "{1}". \
Правило по умолчанию для этой операции имеет тот же тип.
runtimeProtect.dac.ignoringInvalidRule=Проигнорировано недопустимое правило DAC для операции {0}: "{1}". \
Синтаксическая ошибка? Подробности: "{2} ({3})"
runtimeProtect.dac.hostPort=Хост: "{0}", порт: {1}
runtimeProtect.dac.file=Файл: "{0}"
runtimeProtect.dac.nativeLib=Библиотека: "{0}", путь: "{1}"
runtimeProtect.dac.cmd=Команда: "{0}"
runtimeProtect.dac.statusCode=Код состояния: {1}
runtimeProtect.dac.action=Тип действия: {0}
runtimeProtect.dac.prop=Свойство: "{0}"
runtimeProtect.dac.vioDetected=DAC Keiko предотвратил нарушение безопасности ({1}). Подробности: {0}: {2}
runtimeProtect.dac.actionDebug=DAC Keiko зарегистрировал вызов {1}. Откуда: {0}: {2}
runtimeProtect.dac.pkg=Пакет (расположение запрошенного кода): "{0}"
runtimeProtect.dac.op.connection_open=открытие соединения
runtimeProtect.dac.op.connection_listen=прослушивание соединений на порте
runtimeProtect.dac.op.connection_accept=получение данных по порту
runtimeProtect.dac.op.connection_multicast=использование многоадресного вещания
runtimeProtect.dac.op.socket_factory_set=изменение параметров сокета (прокси)
runtimeProtect.dac.op.file_read=чтение файла
runtimeProtect.dac.op.file_write=запись в файл
runtimeProtect.dac.op.file_delete=удаление файла
runtimeProtect.dac.op.natives_linkage=привязка стороннего машинного кода
runtimeProtect.dac.op.command_execution=использование системной команды
runtimeProtect.dac.op.system_exit=незамедлительное завершение работы программы
runtimeProtect.dac.op.properties_access=доступ ко всем свойствам системы сразу
runtimeProtect.dac.op.property_write=изменение свойства системы
runtimeProtect.dac.op.property_read=чтение свойства системы
runtimeProtect.dac.op.package_access=использование пакета Java
runtimeProtect.dac.op.miscellaneous=прочее
updater.checkErr=Не удалось проверить наличие обновлений. Пожалуйста, \
убедитесь, что с Вашим интернет-соединением всё в порядке.
updater.updFound=Доступна новая версия Keiko: {0}
updater.downloading=Скачивается Keiko v{0}, пожалуйста, подождите...
updater.errDownload=Не удалось скачать и/или установить новую версию Keiko
updater.checking=Выполняется проверка на наличие обновлений...
updater.installedLine1=Автоматически установлена новая версия Keiko! 
updater.installedLine2=Сделайте перезапуск, чтобы изменения вступили в силу.
updater.aborting=Запуск прерван: установлена новая версия. Пожалуйста, перезапустите Keiko.
startup.ambiguousInstallation=Неоднозначная установка! Похоже, в этом каталоге у Вас находятся сразу \
несколько JAR-файлов Keiko. Это может сбивать с толку. После обновления \
настоятельно рекомендуется удалять или перемещать старые исполняемые файлы Keiko. \
Запущенный файл: {0}, другой обнаруженный файл: {1}
tool.notFound=Такого инструмента Keiko не существует. Подробнее Вы можете узнать на wiki: \
https://github.com/MeGysssTaa/keiko-plugin-inspector/wiki/Keiko-Tools
tool.err=Произошла внутренняя ошибка.
tool.clean.usage=clean
tool.clean.success=Удалено артефактов: {0} ({1} байт). \
Ошибок: {2}
runtimeProtect.dac.op.minecraft_op_add=выдача игроку опки
runtimeProtect.dac.op.minecraft_op_remove=отнятие у игрока опки
runtimeProtect.dac.op.minecraft_command_dispatch=выполнение команды Minecraft или плагина
runtimeProtect.dac.player=Игрок: "{0}"
runtimeProtect.megane.enabled=Фоновая эвристическая защита от угроз (Keiko Megane) успешно активирована.
runtimeProtect.megane.remedSuccess=Последствия угрозы были успешно устранены Keiko Megane. Ваш сервер в безопасности.
runtimeProtect.megane.remedFailure=Keiko Megane не удалось устранить последствия угрозы. Ваш сервер может быть в опасности!
runtimeProtect.megane.heur.force_op.remedSuccessDetails=Keiko отобрал опку у игрока {0}.
runtimeProtect.megane.heur.force_op.onJoin=Плагин {1} выдал игроку {0} опку при входе на сервер (откуда: {2}#{3}).
runtimeProtect.megane.heur.force_op.onChat=Плагин {1} выдал игроку {0} опку после того, как тот отправил сообщение в чат (откуда: {2}#{3}).
runtimeProtect.megane.heur.force_op.onCmdPrep=Плагин {1} выдал игроку {0} опку после того, как тот использовал команду в чате (откуда: {2}#{3}).
runtimeProtect.megane.heur.force_op.bukkitApi=Для этого плагин воспользовался API Bukkit (встроенными методами).
runtimeProtect.megane.heur.force_op.opCmd=Для этого плагин воспользовался консольной командой "/op".
runtimeProtect.megane.threatDetected=--- ОБНАРУЖЕНА УГРОЗА: {0}
runtimeProtect.megane.heur.book_backdoor.details=Игрок {0} создал книгу с названием "cmd". \
При определённых обстоятельствах эта книга может быть использована для взлома Вашего сервера.
updater.installedLine3=Чтобы ознакомиться с изменениями в этой версии, пройдите по ссылке:
updater.installedLine4=https://github.com/MeGysssTaa/keiko-plugin-inspector/releases
updater.installedLine5=или присоединитесь к Discord-серверу Keiko: https://discord.gg/QWHzCXX
startup.notRelease=Вы используете нестабильную сборку Keiko типа "{0}". \
Эта версия была недостаточно протестирована и может содержать критические баги. \
Подобные версии не рассчитаны на использование на реальном сервере. \
Продолжить в любом случае?
tool.code.usage=code <путь к JAR-файлу>
tool.code.notFile=Указанный файл не существует или является каталогом: "{0}"
tool.code.wait=Выполняется разборка, пожалуйста, подождите...
tool.code.err=Во время выполнения обнаружена по крайней мере одна некритическая ошибка (процесс продолжится):
tool.code.errFatal=Во время выполнения обнаружена по крайней мере одна критическая ошибка (процесс завершится):
tool.code.outExists=Каталог вывода уже существует (удалите или переместите его куда-то): "{0}"
tool.code.outMkFail=Не удалось создать каталог или файл вывода: "{0}"
tool.code.saveErr=Не удалось сохранить файл "{0}". Ошибка: "{1}"
tool.code.complete=Готово! Выходной код Вы можете найти в папке "{0}"
tool.wrongUsage=Вы неправильно использовали этот инструмент. \
Подробности Вы можете найти на Wiki Keiko. \
Синтаксис:
logLevel.user_input_request=вопрос
runtimeProtect.dac.class=Название класса: "{0}"
runtimeProtect.dac.op.class_access=использование класса Java
staticInspections.desc.Static.KeikoHook=|        Плагин {0} (в файле {1}) привязывается к внутреннему коду Keiko. \
У Keiko нет открытых API, на основе которых плагинам разрешено работать. Это \
означает, что этот плагин, скорее всего, вредоносный, и он пытается пробраться \
в реализацию Keiko для обхода его ограничений.
startup.ambiguousPlatform=Неоднозначная платформа: Keiko не может определить тип Вашего сервера между {0} и {1}. \
Keiko будет предполагать, что Ваш сервер -- Bukkit.
startup.unsupportedPlatform=Неподдерживаемая платформа: Keiko не удалось определить тип Вашего сервера.
startup.platform=Платформа (тип сервера): {0}



